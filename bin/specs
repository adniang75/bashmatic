#!/usr/bin/env bash
# vim: ft=sh
# Bashmatic Utilities
# Â© 2016-2020 Konstantin Gredeskoul, All rights reserved. MIT License.
# Distributed under the MIT LICENSE.

# IMPORTANT: Overrride this variable if your tests are located in a different folder, eg 'specs'
export BASHMATIC_TEST_DIR="${BASHMATIC_TEST_DIR:-"test"}"

# @description Checks if we have debug mode enabled
is-dbg() {
  [[ -n $DEBGUG ]]
}

# @description Local debugging helper, activate it with DEBUG=1
dbg() {
  is-dbg && printf "     ${txtgrn}[DEBUG | ${txtylw}$(time.now.with-ms)${txtgrn}]  ${txtblu}$(txt-info)$*\n" >&2
}

# @description
#     Find project root containing our test folder by
#     checking all path components up to /
function specs.find-project-root() {
  local dir="${PWD}"
  while true; do
    [[ "${dir}" == "/" || -z "${dir}" ]] && break
    [[ -d "${dir}/${BASHMATIC_TEST_DIR}" ]] && {
      echo "${dir}"
      return 0
    }
    dir="$(dirname "${dir}")"
  done

  error "Can't find project root containing directory '${BASHMATIC_TEST_DIR}'" \
    "If your tests are located in differently named folder (eg 'specs'), please set"
  "the environment variable before running specs, eg:" \
    "\$ ${bldylw}export BASHMATIC_TEST_DIR=specs; specs" >&2

  return 1
}

# AUTOMATIC variables
export BashmaticBin="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
export BashmaticHome="$(dirname "${BashmaticBin}")"

# Load Bashmatic...
[[ -f "${BashmaticHome}/init.sh" ]] && source "${BashmaticHome}/init.sh"

dbg "Script Source: ${BASH_SOURCE[0]}"

export TERM=${TERM:-xterm-256color}
export MIN_WIDTH=${MIN_WIDTH:-"100"}

export ProjectRoot="$(specs.find-project-root)"
dbg "ProjectRoot is ${ProjectRoot}"

[[ ! -f "${ProjectRoot}/Gemfile.lock" ]] && trap "rm -f ${ProjectRoot}/Gemfile.lock" EXIT

export BatsRoot="${ProjectRoot}/.bats-sources"
export BatsSource="${ProjectRoot}/.bats-sources"
export BatsPrefix="${ProjectRoot}/.bats-prefix"

export PATH="${BatsPrefix}/bin:${BatsPrefix}/libexec:${ProjectRoot}/bin:${ProjectRoot}/test/bin:/usr/bin:/usr/local/bin:/bin:/sbin"

dbg "BatsPrefix is ${BatsPrefix}"

declare -a TestFiles=()

export True=1
export False=0
export GrepCommand="$(which grep) -E -e "

export Bashmatic__Test=${True}

(mkdir -p "${BatsPrefix}" 2>/dev/null) || true
(mkdir -p "${BatsPrefix}"/bin 2>/dev/null) || true
(mkdir -p "${BatsPrefix}"/libexec 2>/dev/null) || true

export PATH="$PATH:${BatsPrefix}/bin:${BatsPrefix}/libexec"

if [[ -n ${CI} ]]; then
  .output.set-indent 0
  color.disable
else
  .output.set-indent 1
  color.enable
fi

specs.test-filename() {
  file=$1
  for f in "${file}" "test/${file}" "test/${file}_tests.bats"; do
    if [[ -s ${f} ]]; then
      printf "%s" "${f}"
      break
    fi
  done
}

specs.usage() {
  echo
  printf "USAGE\n    ${bldgrn}specs [ test1 test2 ... ]${clr}\n\n"
  printf "    ${txtblu}where test1 can be a full filename, or a partial, eg.\n"
  printf "    ${txtblu}'test/util_tests.bats' or just 'util'.\n\n"

  printf "DESCRIPTION\n    ${txtblu}Run BASH tests using Bats framework\n"
  printf "    ${txtblu}Use to run the Bats Test Suite.\n\n"

  printf "OPTIONS\n"
  printf "    -h | --help     Show help message\n\n"

  exit 0
}

specs.install-bats-brew() {
  run "brew tap kaos/shell"
  brew.install.packages bats-assert bats-file bats-assert
}

specs.install-bats-sources() {
  [[ -n $(which bats) ]] && return 0

  run.set-next show-output-off abort-on-error

  [[ ! -d ${BatsRoot} ]] &&
    run "git clone https://github.com/sstephenson/bats.git ${BatsRoot}"

  [[ ! -d "${BatsSource}" ]] &&
    run "cd $(dirname "${BatsSource}") && git clone https://github.com/sstephenson/bats.git $(basename "${BatsSource}")"

  [[ -d "${BatsSource}" && -x "${BatsSource}/install.sh" ]] || {
    error "Can't find Bats source folder: expected ${BatsSource} to contain Bats sources..."
    exit 1
  }

  # Let's update Bats if needed, and run its installer.
  run "cd ${BatsSource} && git reset --hard && git pull --rebase 2>/dev/null || true"
  local prefix="$(cd "${BatsPrefix}" && pwd -P)"
  run "./install.sh ${prefix}"
  run "cd ${ProjectRoot}"
  run 'hash -r'

  [[ ${PATH} =~ ${ProjectRoot}/bin ]] ||
    export PATH="${ProjectRoot}/bin:${ProjectRoot}/test/bin:${PATH}"
}

specs.install-bats() {
  local install_type="${1:-"sources"}"
  local func="specs.install-bats-${install_type}"

  util.is-a-function "${func}" || {
    error "Install method ${install_type} is unsupported." \
      "Currently available: brew and sources."
    return 1
  }

  ${func}
}

spec.find-bats() {
  command -v bats || which bats || find . -name bats -perm "-u=x" | ${GrepCommand} -v 'fixtures|libexec'
}

specs.run-file() {
  local file="$1"
  if [[ -z "${file}" ]]; then
    error "No argument provided"
    return 1
  fi
  if [[ ! -s "${file}" ]]; then
    error "File ${file} is not found."
    return 1
  fi
  test-group "${file}"
  set -e

  local bats=$(spec.find-bats)

  [[ -z ${bats} ]] && {
    echo "ERROR: can't find bats executable :("
    echo
    echo "which bats:                      $(which bats)"
    echo "command -v bats:                 $(command -v bats)"
    echo "find ${BatsRoot} -name bats:     $(find ${BatsRoot} -name bats)"
    exit 1
  }

  ${bats} -p "${file}"
  set +e
}

specs.select-files() {
  export os="$(uname -s | tr '[:upper:]' '[:lower:]')"
  if [[ -z ${TestFiles[*]} ]]; then
    TestFiles=($(find "${BASHMATIC_TEST_DIR}" -name '*test*.bats' -depth 1 | sort))
    [[ -d "${BASHMATIC_TEST_DIR}/${os}" ]] && TestFiles+=($(find "${BASHMATIC_TEST_DIR}/${os}" -name '*test*.bats' -depth 1 | sort))
  fi
  export TestFiles
}

specs.run-all() {
  for file in ${TestFiles[@]}; do
    set +e
    specs.run-file "${file}"
  done
}

specs.main() {
  specs.install-bats sources
  specs.select-files
  specs.run-all
}

trap 'printf "\n\n\n${bldred}BOOOOM! Ctrl-C will set you free...${clr}\n\n"; exit 1' SIGINT

# Parse additional flags
while :; do
  case $1 in
  -h | -\? | --help)
    shift
    specs.usage
    exit 0
    ;;
  --) # End of all options; anything after will be passed to the action function
    shift
    break
    ;;
  -?*)
    printf 'WARN: Unknown option (ignored): %s\n' "$1" >&2
    exit 127
    shift
    ;;
  *) # Default case: If no more options then break out of the loop.
    [[ -z ${1} ]] && break
    file=$(specs.test-filename "$1")
    [[ -n "${file}" ]] && TestFiles=(${TestFiles[@]} ${file})
    shift
    ;;
  esac
done

specs.main "$@"
