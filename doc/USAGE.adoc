= BashMatic® Auto-Generated Function Index
:doctype: book

[discrete]
=== Index

* <<arrayhas-element,array.has-element()>>
* <<arrayincludes,array.includes()>>
* <<arrayjoin,array.join()>>
* <<arraysort,array.sort()>>
* <<arraysort-numeric,array.sort-numeric()>>
* <<arraymin,array.min()>>
* <<arraymax,array.max()>>
* <<arrayuniq,array.uniq()>>

[discrete]
==== array.has-element()

Returns "true" if the first argument is a member of the array
passed as the second argument:

.Example
[source,bash]
----
$ declare -a array=("a string" test2000 moo)
if [[ $(array.has-element "a string" "${array[@]}") == "true" ]]; then
  ...
fi
----

[discrete]
==== array.includes()

Similar to array.has-elements, but does not print anything, just
returns 0 if includes, 1 if not.

[discrete]
==== array.join()

Joins a given array with a custom character

.Example
[source,bash]
----
$ declare -a array=(one two three)
$ array.join "," "${array[@]}"
one,two,three
----

[discrete]
==== array.sort()

Sorts the array alphanumerically and prints it to STDOUT

.Example
[source,bash]
----
declare -a unsorted=(hello begin again again)
local sorted="$(array.sort "${unsorted[@]}")"
----

[discrete]
==== array.sort-numeric()

Sorts the array numerically and prints it to STDOUT

.Example
[source,bash]
----
declare -a unsorted=(1 2 34 45 6)
local sorted="$(array.sort-numeric "${unsorted[@]}")"
----

[discrete]
==== array.min()

Returns a minimum integer from an array.
Non-numeric elements are ignored and skipped over.
Negative numbers are supported, but non-integers are not.

.Example
[source,bash]
----
$ declare -a array=(10 20 30 -5 5)
$ array.min "," "${array[@]}"
-5
----

[discrete]
==== array.max()

Returns a maximum integer from an array.
Non-numeric elements are ignored and skipped over.
Negative numbers are supported, but non-integers are not.

.Example
[source,bash]
----
$ declare -a array=(10 20 30 -5 5)
$ array.min "," "${array[@]}"
30
----

[discrete]
==== array.uniq()

Sorts and uniqs the array and prints it to STDOUT

.Example
[source,bash]
----
declare -a unsorted=(hello hello hello goodbye)
local uniqued="$(array.sort-numeric "${unsorted[@]}")"
----

[discrete]
=== Index

* <<section,section()>>
* <<is-dbg,is-dbg()>>
* <<dbg,dbg()>>

[discrete]
==== section()

Prints a "arrow-like" line using powerline characters

[discrete]
===== Arguments

* {blank}
+
= @arg1 Width (optional) -- only intepretered as width if the first argument is a number.
* {blank}
+
= @args Text to print

[discrete]
==== is-dbg()

Checks if we have debug mode enabled

[discrete]
==== dbg()

Local debugging helper, activate it with DEBUG=1

[discrete]
=== Index

* <<pathadd,path.add()>>
* <<pathappend,path.append()>>
* <<pathadd,PATH_add()>>

[discrete]
==== path.add()

Adds valid directories to those in the PATH and prints
to the output. DOES NOT MODIFY $PATH

[discrete]
==== path.append()

Appends valid directories to those in the PATH, and
exports the new value of the PATH

[discrete]
==== PATH_add()

This function exists within direnv, but since we
are sourcing in .envrc we need to have this defined
to avoid errors.

== osx.sh

=== Overview

OSX Specific Helpers and Utilities

=== Index

* <<osxappis-installed,osx.app.is-installed()>>

==== osx.app.is-installed()

Checks if a given parameter matches any of the installed applications
under /Applications and ~/Applications

By the default prints the matched application. Pass `-q` as a second
argument to disable output.

===== Example

[source,bash]
----
❯ osx.app.is-installed safari
Safari.app
❯ osx.app.is-installed safari -q && echo installed
installed
❯ osx.app.is-installed microsoft -c
6
----

===== Arguments

* *$1* (a): string value to match (case insentively) for an app name
* $2.. additional arguments to the last invocation of `grep`

===== Exit codes

* *0*: if match was found
* *1*: if not

=== Index

* <<dbconfigparse,db.config.parse()>>
* <<dbpsqlconnect,db.psql.connect()>>
* <<dbpsqlconnectjust-data,db.psql.connect.just-data()>>
* <<dbpsqlconnecttable-settings-set,db.psql.connect.table-settings-set()>>
* <<dbpsqldb-settings,db.psql.db-settings()>>
* <<dbpsqlconnectdb-settings-pretty,db.psql.connect.db-settings-pretty()>>
* <<dbpsqlconnectdb-settings-toml,db.psql.connect.db-settings-toml()>>

==== db.config.parse()

Returns a space-separated values of db host, db name, username and password

===== Example

[source,bash]
----
db.config.set-file ~/.db/database.yml
db.config.parse development
##=> hostname dbname dbuser dbpass
declare -a params=($(db.config.parse development))
echo ${params[0]} # host
----

==== db.psql.connect()

Connect to one of the databases named in the YAML file, and
optionally pass additional arguments to psql.
Informational messages are sent to STDERR.

===== Example

[source,bash]
----
db.psql.connect production
db.psql.connect production -c 'show all'
----

==== db.psql.connect.just-data()

Similar to the db.psql.connect, but outputs
just the raw data with no headers.

===== Example

[source,bash]
----
db.psql.connect.just-data production -c 'select datname from pg_database;'
----

==== db.psql.connect.table-settings-set()

Set per-table settings, such as autovacuum, eg:

===== Example

[source,bash]
----
db.psql.connect.table-settings-set prod users autovacuum_analyze_threshold 1000000
db.psql.connect.table-settings-set prod users autovacuum_analyze_scale_factor 0
----

==== db.psql.db-settings()

Print out PostgreSQL settings for a connection specified by args

===== Example

[source,bash]
----
db.psql.db-settings -h localhost -U postgres appdb
----

==== db.psql.connect.db-settings-pretty()

Print out PostgreSQL settings for a named connection

===== Example

[source,bash]
----
db.psql.connect.db-settings-pretty primary
----

===== Arguments

* {blank}
+
= @arg1 dbname database entry name in ~/.db/database.yml

[discrete]
==== db.psql.connect.db-settings-toml()

Print out PostgreSQL settings for a named connection using TOML/ini
format.

.Example
[source,bash]
----
db.psql.connect.db-settings-toml primary > primary.ini
----

[discrete]
===== Arguments

* {blank}
+
= @arg1 dbname database entry name in ~/.db/database.yml

== lib/shdoc.sh

Helpers to install gawk and shdoc properly.0

=== Overview

see `+${BASHMATIC_HOME}/lib/shdoc.md+` for an example of how to use SHDOC.
and also https://github.com/reconquest/shdoc[project's github page].

=== Index

* <<gawkinstall,gawk::install()>>
* <<shdocinstall,shdoc::install()>>
* <<shdocreinstall,shdoc::reinstall()>>

==== gawk::install()

Installs gawk into /usr/local/bin/gawk

==== shdoc::install()

Installs shdoc unless already exists

==== shdoc::reinstall()

Reinstall shdoc completely

== Bashmatic Utilities and aliases for Git revision control system.

=== Overview

Lots of useful utilities and helpers.

=== Index

* <<gitopen,git.open()>>

==== git.open()

Reads the remote of a repo by name provided as
an argument (or defaults to "origin") and opens it in the browser.

===== Example

[source,bash]
----
git clone git@github.com:kigster/bashmatic.git
cd bashmatic
source init.sh
git.open
git.open origin # same thing
----

===== Arguments

* *$1* (optional): name of the remote to open, defaults to "orogin"

=== Index

* <<pgis-running,pg.is-running()>>
* <<pgrunningserver-binaries,pg.running.server-binaries()>>
* <<pgrunningdata-dirs,pg.running.data-dirs()>>
* <<pgserver-in-pathversion,pg.server-in-path.version()>>

==== pg.is-running()

Returns true if PostgreSQL is running locally

==== pg.running.server-binaries()

if one or more PostgreSQL instances is running locally,
prints each server's binary +postgres+ file path

==== pg.running.data-dirs()

For each running server prints the data directory

==== pg.server-in-path.version()

Grab the version from `postgres` binary in the PATH and remove fractional sub-version

=== Index

* <<dirshort-home,dir.short-home()>>

==== dir.short-home()

Replaces the first part of the directory that matches $\{HOME} with '~/'

== is.sh

=== Overview

Various validations and asserts that can be chained
and be explicit in a DSL-like way.

=== Index

* <<isvalidationerror,__is.validation.error()>>
* <<is-validations,is-validations()>>
* <<isvalidationignore-error,__is.validation.ignore-error()>>
* <<isvalidationreport-error,__is.validation.report-error()>>
* <<whenever,whenever()>>

==== __is.validation.error()

Invoke a validation on the value, and process
the invalid case using a customizable error handler.

===== Arguments

* {blank}
+
= @arg1 func        Validation function name to invoke
* {blank}
+
= @arg2 var         Value under the test
* {blank}
+
= @arg4 error_func  Error function to call when validation fails

[discrete]
===== Exit codes

* *0*: if validation passes

[discrete]
==== is-validations()

Returns the list of validation functions available

[discrete]
==== __is.validation.ignore-error()

Private function that ignores errors

[discrete]
==== __is.validation.report-error()

Private function that ignores errors

[discrete]
==== whenever()

a convenient DSL for validating things

.Example
[source,bash]
----
whenever /var/log/postgresql.log is.an-empty-file && {
   touch /var/log/postgresql.log
}
----

== util.sh

=== Overview

Miscellaneous utilities.

=== Index

* <<utilrot13-stdin,util.rot13-stdin()>>

==== util.rot13-stdin()

Convert STDIN using rot13

===== Example

[source,bash]
----
echo "test" | util.rot13-stdin
----

== Bashmatic Utilities for PDF file handling

=== Overview

Install and uses GhostScript to manipulate PDFs.

=== Index

* <<pdfcombine,pdf.combine()>>

==== pdf.combine()

Combine multiple PDFs into a single one using ghostscript.

===== Example

[source,bash]
----
pdf.combine ~/merged.pdf 'my-book-chapter*'
----

===== Arguments

* *$1* (pathname): to the merged file
* *...* (the): rest of the PDF files to combine
